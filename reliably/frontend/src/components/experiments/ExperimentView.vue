<template>
  <LoadingPlaceholder size="large" v-if="isLoading" />
  <article
    class="experimentView"
    v-else-if="exp !== undefined && exp !== null && exp.id !== undefined"
  >
    <header class="pageHeader">
      <div>
        <h1 class="pageHeader__title">
          <span>
            {{ exp.definition.title }}
            <small>{{ shortenUuid(exp.definition.uuid!) }}</small>
          </span>
        </h1>
        <p v-if="exp.definition.description" class="pageHeader__description">
          {{ exp.definition.description }}
        </p>
      </div>
      <div class="pageHeader__actions">
        <MultiButton
          title="Manage experiment"
          :options="manageActions"
          @emit-action="handleMultiButtonAction"
        />
        <a :href="`/plans/new/?exp=${exp.id}`" class="button button--creative">
          Run experiment
        </a>
      </div>
    </header>
    <section v-if="question !== ''" class="experimentAssistantInfo">
      <div
        class="AiIcon AiIcon--medium hasTooltip hasTooltip--center-top"
        aria-label="This experiment was generated by Reliably Assistant"
        label="This experiment was generated by Reliably Assistant"
      ></div>
      <div class="experimentAssistantInfo__question">
        <p class="experimentAssistantInfo__heading">Question</p>
        <p class="experimentAssistantInfo__details">
          {{ question }}
        </p>
      </div>
      <div v-if="s!.query.tags.length" class="experimentAssistantInfo__tags">
        <p class="experimentAssistantInfo__heading">Tags</p>
        <p class="experimentAssistantInfo__details pills">
          <span v-for="t in s!.query.tags" :key="t" class="pill">{{ t }}</span>
        </p>
      </div>
    </section>
    <section class="experimentInfo">
      <dl>
        <div class="experimentInfo__score">
          <dt>Score</dt>
          <dd>
            <ExperimentScore
              v-if="exp.score !== undefined && exp.score !== null"
              :score="exp.score.score"
            />
            <ExperimentScore v-else :score="null" />
          </dd>
        </div>
        <div class="experimentInfo__trend">
          <dt>Trend</dt>
          <dd>
            <ExperimentTrend
              v-if="exp.score !== undefined && exp.score !== null"
              :trend="exp.score.trend"
              :exp="exp.id"
            />
          </dd>
        </div>
        <div class="experimentInfo__freshness">
          <dt>Freshness</dt>
          <dd>
            <ExperimentFreshness :last="lastExecution" />
          </dd>
        </div>
        <div class="experimentInfo__created">
          <dt>Created</dt>
          <dd>
            <TimeAgo :timestamp="exp.created_date.toString()" />
            <span v-if="exp.created_by">by {{ exp.created_by }}</span>
          </dd>
        </div>
        <div class="experimentInfo__lastRun">
          <dt>Last run</dt>
          <dd><TimeAgo :timestamp="lastExecution" /></dd>
        </div>
      </dl>
    </section>
    <section class="experimentMeta">
      <button
        @click="displayExperimentDefinition"
        class="button button--icon experimentMeta__src hasTooltip hasTooltip--center-left"
        aria-label="View Experiment"
        label="View Experiment"
      >
        {&nbsp;}
      </button>
      <div class="experimentMeta__section">
        <ContributionsRadar :contributions="exp.definition.contributions" />
        <div class="experimentTags">
          <h2>Tags</h2>
          <TagList v-if="hasTags" :tags="exp.definition.tags!" />
          <p v-else>This experiment doesn't declare tags.</p>
        </div>
      </div>
      <div class="experimentMeta__section">
        <div class="experimentSsh" v-if="sshStrategyHasPrecheck">
          <h2>Pre-condition</h2>
          <dl v-if="hasSSh">
            <p class="screen-reader-text">
              Title: {{ exp.definition["steady-state-hypothesis"]!.title }}
            </p>
            <div v-if="hasSshProbes">
              <SshProbesList
                :probes="exp.definition['steady-state-hypothesis']!.probes!"
              />
            </div>
          </dl>
        </div>
        <div class="experimentMethod">
          <h2>Turbulence</h2>
          <ExperimentMethod v-if="hasMethod" :method="exp.definition.method!" />
          <p v-else>
            This experiment's method doesn't declare any actions or probes
          </p>
        </div>
        <div class="experimentSsh">
          <h2>Verification</h2>
          <dl v-if="hasSSh && sshStrategyHasVerification">
            <p class="screen-reader-text">
              Title: {{ exp.definition["steady-state-hypothesis"]!.title }}
            </p>
            <div v-if="hasSshProbes">
              <SshProbesList
                :probes="exp.definition['steady-state-hypothesis']!.probes!"
              />
            </div>
          </dl>
          <p v-else>
            This experiment doesn't declare a verification step
          </p>
        </div>
        <div class="experimentRollbacks">
          <h2>Rollbacks</h2>
          <ExperimentMethod
            v-if="hasRollbacks"
            :method="exp.definition.rollbacks!"
          />
          <p v-else>This experiment doesn't declare rollbacks</p>
        </div>
        <div class="experimentControls">
          <h2>Controls</h2>
          <ExperimentGenericList
            v-if="hasControls"
            :content="exp.definition.controls!"
          />
          <p v-else>This experiment doesn't declare controls</p>
        </div>
      </div>
    </section>
    <section class="experimentStrategyWrapper">
      <h2>Runtime configuration</h2>
      <ExperimentStrategy :strategy="exp.definition.runtime" />
    </section>
    <section
      v-if="experimentEnv || experimentConf"
      class="executionSection executionSection--env"
    >
      <h2>Configuration</h2>
      <ExecutionEnvironment
        :conf="experimentConf"
        :is-editable="true"
        :experiment="id"
      />
    </section>
    <section class="experimentPlans">
      <ExperimentPlans :experimentId="exp.id" />
    </section>
    <section ref="experimentExecutions" class="experimentExecutions">
      <ExperimentExecutions :experimentId="exp.id" />
    </section>
    <ModalWindow
      v-if="isDeleteDisplayed"
      :hasCloseButton="true"
      :hasPadding="true"
      @close="closeDelete"
    >
      <template #title>Delete Experiment</template>
      <template #content>
        <ConfirmDeleteExperiment :id="exp.id" @close="closeDelete" />
      </template>
    </ModalWindow>
    <ModalWindow
      v-if="isDefinitionDisplayed"
      :isUnlimited="true"
      :hasCloseButton="true"
      @close="closeExperimentDefinition"
    >
      <template #title>Experiment Definition</template>
      <template #content>
        <JsonViewer :json="JSON.stringify(exp.definition, null, 2)" />
      </template>
    </ModalWindow>
  </article>
  <NoData v-else message="We couldn't find an experiment with this ID." />
</template>

<script setup lang="ts">
import { ref, computed, watch, onMounted } from "vue";
import { shortenUuid } from "@/utils/strings";
import type { Experiment } from "@/types/experiments";
import type { MultiButtonOption } from "@/types/ui-types";
import { useStore } from "@nanostores/vue";

import { experiment, fetchExperiment } from "@/stores/experiments";
import { experimentStatus, fetchExperimentStatus } from "@/stores/executions";
import { scenario, fetchScenarioByExperiment } from "@/stores/scenarios";

import LoadingPlaceholder from "@/components/_ui/LoadingPlaceholder.vue";
import NoData from "@/components/_ui/NoData.vue";
import ModalWindow from "@/components/_ui/ModalWindow.vue";
import MultiButton from "@/components/_ui/MultiButton.vue";
import TagList from "@/components/_ui/TagList.vue";
import TimeAgo from "@/components/_ui/TimeAgo.vue";
import JsonViewer from "@/components/_ui/JsonViewer.vue";
import ConfirmDeleteExperiment from "@/components/experiments/ConfirmDeleteExperiment.vue";
import ExperimentScore from "@/components/experiments/ExperimentScore.vue";
import ExperimentFreshness from "@/components/experiments/ExperimentFreshness.vue";
import ExperimentTrend from "@/components/experiments/ExperimentTrend.vue";
import ExperimentStrategy from "@/components/experiments/ExperimentStrategy.vue";
import ExecutionEnvironment from "@/components/executions/ExecutionEnvironment.vue";
import ContributionsRadar from "@/components/charts/ContributionsRadar.vue";
import SshProbesList from "@/components/experiments/SshProbesList.vue";
import ExperimentGenericList from "@/components/experiments/ExperimentGenericList.vue";
import ExperimentMethod from "@/components/experiments/ExperimentMethod.vue";
import ExperimentExecutions from "@/components/executions/ExperimentExecutions.vue";
import ExperimentPlans from "@/components/plans/ExperimentPlans.vue";

const isLoading = ref(true);
const id = ref<string | undefined>(undefined);
const exp = ref<Experiment | undefined>(undefined);

const getCurrentId = () => {
  let location = window.location;
  let params = new URLSearchParams(location.search);
  if (params.has("id")) {
    id.value = params.get("id")!;
  }
};

const getExperiment = async () => {
  await fetchExperiment(id.value!);
  exp.value = experiment.get() as Experiment;
};

const setMetaData = () => {
  let title = "Experiment · Reliably";
  let description = "View your Reliably experiment details";
  if (exp.value !== undefined && exp.value !== null) {
    title = `${exp.value.definition.title} · Reliably`;
    if (exp.value.definition.description !== undefined) {
      description = exp.value.definition.description;
    }
  }
  document.title = title;
  const meta: HTMLElement | null = document.querySelector(
    "meta[name='description']"
  );
  if (meta instanceof HTMLMetaElement) {
    meta.content = description;
  }
};

const sshStrategyHasPrecheck = computed<boolean>(() => {
  const x = exp.value;
  if (x !== undefined) {
    const strategy = x.definition.runtime?.hypothesis?.strategy;
    if (strategy !== undefined) {
      return strategy === "default" || strategy === "before-method-only";
    }
  }

  return false;
});

const sshStrategyHasVerification = computed<boolean>(() => {
  const x = exp.value;
  if (x !== undefined) {
    const strategy = x.definition.runtime?.hypothesis?.strategy;
    if (strategy !== undefined) {
      return strategy === "default" || strategy === "after-method-only";
    }
  }

  return false;
});

const isEditable = computed<boolean>(() => {
  if (exp) {
    const extensions = exp.value?.definition.extensions;
    if (extensions) {
      const i: number = extensions.findIndex((ext) => {
        return ext.name === "reliablyui";
      });
      if (i > -1) {
        return extensions[i].workflow !== undefined;
      }
    }
  }
  return false;
});

const manageActions = ref<MultiButtonOption[]>([
  {
    label: "Edit",
    link: "#",
    icon: "edit",
    disabled: true,
    reason: "Only experiments created with the Builder can be edited",
  },
  {
    label: "Delete",
    action: "delete",
    icon: "trash",
    warning: true,
  },
]);

function updateManageActions() {
  if (id.value) {
    manageActions.value[0].link = `/experiments/workflows/build/?edit=${id.value}`;
  }
  if (isEditable.value) {
    manageActions.value[0].disabled = false;
  }
}

async function handleMultiButtonAction(action: string) {
  if (action === "delete") {
    displayDelete();
  }
}

const lastStatus = ref<string>("unknown");
const lastExecution = ref<string>("");

const getStatus = async () => {
  let storedStatus = useStore(experimentStatus);
  if (storedStatus.value.experimentId !== id.value) {
    await fetchExperimentStatus(id.value!);
  }
  if (storedStatus.value.lastStatuses[0] !== undefined) {
    lastStatus.value = storedStatus.value.lastStatuses[0];
  }

  if (storedStatus.value.lastExecution === null) {
    lastExecution.value = "";
  } else if (storedStatus.value.lastExecution instanceof Date) {
    lastExecution.value = storedStatus.value.lastExecution.toString();
  } else {
    lastExecution.value = storedStatus.value.lastExecution;
  }
};

const s = useStore(scenario);
const question = ref<string>("");
async function getScenario() {
  await fetchScenarioByExperiment(id.value!, false, true);
  if (s.value) {
    question.value = s.value.query.question;
  }
}

const hasTags = computed<boolean>(() => {
  if (exp.value === undefined || exp.value.definition.tags === undefined) {
    return false;
  }
  return exp.value.definition.tags.length > 0;
});

const hasControls = computed<boolean>(() => {
  if (exp.value === undefined || exp.value.definition.controls === undefined) {
    return false;
  }
  return exp.value.definition.controls.length > 0;
});

const hasMethod = computed<boolean>(() => {
  if (exp.value === undefined || exp.value.definition.method === undefined) {
    return false;
  }
  return exp.value.definition.method.length > 0;
});

const hasSSh = computed<boolean>(() => {
  if (
    exp.value === undefined ||
    exp.value.definition["steady-state-hypothesis"] === undefined
  ) {
    return false;
  } else {
    return true;
  }
});

const hasSshProbes = computed<boolean>(() => {
  if (
    exp.value === undefined ||
    exp.value.definition["steady-state-hypothesis"] === undefined ||
    exp.value.definition["steady-state-hypothesis"].probes === undefined
  ) {
    return false;
  }
  return exp.value.definition["steady-state-hypothesis"].probes.length > 0;
});

const hasRollbacks = computed<boolean>(() => {
  if (exp.value === undefined || exp.value.definition.rollbacks === undefined) {
    return false;
  }
  return exp.value.definition.rollbacks.length > 0;
});

const experimentEnv = null;
const experimentConf = computed(() => {
  if (exp.value?.definition.configuration) {
    return exp.value.definition.configuration;
  } else {
    return null;
  }
});

const isDefinitionDisplayed = ref<boolean>(false);
const displayExperimentDefinition = () => {
  isDefinitionDisplayed.value = true;
};
const closeExperimentDefinition = () => {
  isDefinitionDisplayed.value = false;
};

// Scroll to executions list of an executions page number is present in the URL
// as it means the user probably just used the pager to display another page of
// executions
const experimentExecutions = ref(null);
function scrollToExecutions() {
  if (experimentExecutions.value) {
    let location = window.location;
    let params = new URLSearchParams(location.search);
    if (params.has("executions")) {
      (experimentExecutions.value as HTMLElement).scrollIntoView({
        behavior: "smooth",
        block: "center",
      });
    }
  }
}
watch(experimentExecutions, () => {
  scrollToExecutions();
});

const isDeleteDisplayed = ref<boolean>(false);

const displayDelete = () => {
  isDeleteDisplayed.value = true;
};
const closeDelete = () => {
  isDeleteDisplayed.value = false;
};

onMounted(async () => {
  isLoading.value = true;
  getCurrentId();
  await getExperiment();
  setMetaData();
  await getStatus();
  updateManageActions();
  await getScenario();
  isLoading.value = false;
});
</script>

<style lang="scss" scoped>
.experimentView {
  > section + section {
    margin-top: var(--space-large);
  }

  .experimentAssistantInfo {
    display: flex;
    align-items: center;
    gap: var(--space-small);

    &__heading {
      color: var(--text-color-dim);
      font-size: 1.4rem;
      text-transform: uppercase;
    }

    &__details {
      margin-top: 0;

      font-size: 2.4rem;

      &:first-letter {
        text-transform: capitalize;
      }
    }

    > div:not(-first-child) {
      padding-left: var(--space-small);

      border-left: 0.1rem solid var(--section-separator-color);
    }
  }

  .experimentInfo {
    padding: var(--space-small);

    background-color: var(--section-background);
    border-radius: var(--border-radius-s);

    dl {
      display: grid;
      grid-template-columns: min-content min-content min-content auto auto;
      margin: 0;

      > div {
        padding-right: var(--space-small);
      }

      > div + div {
        padding-left: var(--space-small);

        border-left: 1px solid var(--section-separator-color);
      }

      dt {
        margin-bottom: var(--space-small);

        color: var(--text-color-dim);
        font-size: 1.4rem;
        text-transform: uppercase;
      }
    }

    &__trend {
      display: flex;
      flex-direction: column;
      dd {
        // display: flex;
        // justify-self: flex-end;
        margin-top: auto;
      }
    }
  }

  .experimentMeta {
    position: relative;

    display: grid;
    grid-template-columns: 1fr 2fr;
    gap: var(--space-medium);

    padding: var(--space-small);

    background-color: var(--section-background);
    border-radius: var(--border-radius-s);

    &__section {
      > div + div {
        margin-top: var(--space-medium);
      }
    }

    &__src {
      position: absolute;
      top: var(--space-small);
      right: var(--space-small);

      display: flex;
      align-items: center;
      justify-content: center;

      font-size: 1.8rem;
      font-weight: 500;
    }
  }

  .experimentStrategy {
    position: relative;

    padding: var(--space-small);

    background-color: var(--section-background);
    border-radius: var(--border-radius-s);

    &__wrapper {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: var(--space-medium);
    }
  }
}
</style>
