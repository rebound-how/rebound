import asyncio
import logging
from pathlib import Path

from alembic import context
from sqlalchemy import engine_from_config, pool
from sqlalchemy.engine import Connection, Engine
from sqlalchemy.ext.asyncio.engine import (
    AsyncConnection,
    AsyncEngine,
)

from reliably_app.config import Settings, get_settings
from reliably_app.database import create_ssl_context, meta
from reliably_app.models import import_models

logger = logging.getLogger("reliably_app")

config = context.config
target_metadata = meta
import_models()


def engine_config(settings: Settings) -> dict:
    cfg = {}

    if settings.DATABASE_WITH_SSL:
        cfg["connect_args"] = {"ssl": create_ssl_context(settings)}

    return cfg


def include_object(object, name, type_, reflected, compare_to) -> bool:  # type: ignore
    """
    Exclude SQL Views from being autogenerated by alembic,
    needs manual creation in the alembic revision as well as
    SQLAlchemy table definition at code level
    """
    if type_ == "table" and name and name.endswith("_view"):
        return False

    return True


# https://stackoverflow.com/a/71212675/1363905
def process_revision_directives(context, revision, directives) -> None:  # type: ignore
    script = directives[0]
    if script.upgrade_ops.is_empty():
        directives[:] = []
        logger.info("No changes detected")


def do_run_migrations(connection: Connection | AsyncConnection) -> None:
    context.configure(
        connection=connection,  # type: ignore
        target_metadata=target_metadata,
        render_as_batch=True,
        include_object=include_object,
        compare_type=True,
        process_revision_directives=process_revision_directives,
    )

    with context.begin_transaction():
        logger.debug("Running migrations")
        context.run_migrations()


async def run_async_migrations_online(connectable: AsyncEngine | None) -> None:
    dispose = False

    # otherwise, we create one as we are running a migration live
    if not connectable:
        dispose = True
        env_file = Path(config.get_main_option("env_file"))  # type: ignore
        settings = get_settings(env_file)
        config.set_main_option("sqlalchemy.url", str(settings.DATABASE_URL))
        connectable = AsyncEngine(
            engine_from_config(  # type: ignore
                config.get_section(config.config_ini_section),
                prefix="sqlalchemy.",
                poolclass=pool.NullPool,
                future=True,
                **engine_config(settings),
            )
        )

    async with connectable.connect() as connection:
        await connection.run_sync(do_run_migrations)

    if dispose and connectable:
        await connectable.dispose()


def run_sync_migrations_online(connectable: Engine | None) -> None:
    dispose = False

    # otherwise, we create one as we are running a migration live
    if not connectable:
        env_file = Path(config.get_main_option("env_file"))  # type: ignore
        settings = get_settings(env_file)
        config.set_main_option("sqlalchemy.url", str(settings.DATABASE_URL))
        connectable = engine_from_config(
            config.get_section(config.config_ini_section),
            prefix="sqlalchemy.",
            poolclass=pool.NullPool,
            **engine_config(settings),
        )

    try:
        with connectable.connect() as connection:
            do_run_migrations(connection)
    finally:
        if dispose and connectable:
            connectable.dispose()


def run_migrations_online() -> None:
    """Run migrations in 'online' mode."""
    connectable: Engine | AsyncEngine = config.attributes.get(
        "connection", None
    )

    if isinstance(connectable, AsyncEngine) or connectable is None:
        asyncio.run(run_async_migrations_online(connectable))
    else:
        run_sync_migrations_online(connectable)


run_migrations_online()
